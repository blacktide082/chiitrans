// Generated by CoffeeScript 1.7.1
var Cell, INTERSECT_CHANCE, Mob, Region, RegionTraits, Stage, Terrain, Timeline, attempt, chance, coinflip, glyphSize, nextId, onDone, process, random, randomBetween, randomIn, randomMob, randomOf, repeat, setup, showActions, showMap, _id,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

random = function(x) {
  return Math.floor(Math.random() * x);
};

randomBetween = function(x, y) {
  return x + random(y - x + 1);
};

randomIn = function(x, y) {
  return x + random(y - x);
};

randomOf = function(a) {
  return a[random(a.length)];
};

chance = function(x) {
  return Math.random() < x;
};

coinflip = function() {
  return chance(1 / 2);
};

attempt = function(maxAttempts, fn) {
  var i, _i;
  for (i = _i = 0; 0 <= maxAttempts ? _i < maxAttempts : _i > maxAttempts; i = 0 <= maxAttempts ? ++_i : --_i) {
    if (fn(i)) {
      return true;
    }
  }
  return false;
};

repeat = function(n, fn) {
  var i, _i;
  for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
    fn(i);
  }
};

_id = 0;

nextId = function() {
  return ++_id;
};

Terrain = {
  FLOOR: 0,
  WALL: 1,
  DOOR: 2,
  WATER: 3
};

INTERSECT_CHANCE = 1 / 8;

Cell = (function() {
  function Cell() {
    this.terrain = Terrain.WALL;
  }

  Cell.prototype.canEnter = function(mob) {
    return this.terrain === Terrain.FLOOR && (this.mob == null);
  };

  Cell.prototype.copy = function() {
    var res;
    res = new Cell;
    if (this.terrain != null) {
      res.terrain = this.terrain;
    }
    if (this.mob != null) {
      res.mob = this.mob;
    }
    return res;
  };

  Cell.prototype.toString = function() {
    if (this.mob != null) {
      return this.mob.toString();
    } else {
      switch (this.terrain) {
        case Terrain.WALL:
          return '#';
        case Terrain.DOOR:
          return '+';
        case Terrain.WATER:
          return '~';
        default:
          return '.';
      }
    }
  };

  return Cell;

})();

RegionTraits = (function() {
  function RegionTraits() {}

  RegionTraits.prototype.isInside = function(x, y) {
    return (0 <= x && x < this.mx) && (0 <= y && y < this.my);
  };

  RegionTraits.prototype.randomPoint = function() {
    return {
      x: random(this.mx),
      y: random(this.my)
    };
  };

  RegionTraits.prototype.toString = function() {
    var x, y;
    return ((function() {
      var _i, _ref, _results;
      _results = [];
      for (y = _i = 0, _ref = this.my; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        _results.push(((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (x = _j = 0, _ref1 = this.mx; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
            _results1.push(this.grid[y * this.mx + x].toString());
          }
          return _results1;
        }).call(this)).join(''));
      }
      return _results;
    }).call(this)).join('\n');
  };

  RegionTraits.prototype.insideArea = function(margin) {
    if (margin == null) {
      margin = 1;
    }
    return new Region(this, margin, margin, this.mx - margin * 2, this.my - margin * 2);
  };

  RegionTraits.prototype.iterate = function(fn) {
    var x, y, _i, _j, _ref, _ref1;
    for (y = _i = 0, _ref = this.my; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
      for (x = _j = 0, _ref1 = this.mx; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
        fn(this.at(x, y), x, y);
      }
    }
  };

  RegionTraits.prototype.stage = function() {
    var _ref, _ref1;
    return (_ref = (_ref1 = this.parent) != null ? _ref1.stage() : void 0) != null ? _ref : this;
  };

  RegionTraits.prototype.adjacent = function(_arg) {
    var res, x, xx, y, yy, _i, _j, _ref, _ref1, _ref2, _ref3;
    x = _arg.x, y = _arg.y;
    res = [];
    for (yy = _i = _ref = y - 1, _ref1 = y + 1; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; yy = _ref <= _ref1 ? ++_i : --_i) {
      for (xx = _j = _ref2 = x - 1, _ref3 = x + 1; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; xx = _ref2 <= _ref3 ? ++_j : --_j) {
        if (!(x === xx && y === yy) && this.isInside(xx, yy)) {
          res.push({
            cell: this.at(xx, yy),
            x: xx,
            y: yy
          });
        }
      }
    }
    return res;
  };

  RegionTraits.prototype.atPoint = function(_arg) {
    var x, y;
    x = _arg.x, y = _arg.y;
    return this.at(x, y);
  };

  return RegionTraits;

})();

Timeline = (function() {
  function Timeline() {
    this.time = 0;
    this.actors = [];
  }

  Timeline.prototype.add = function(actor) {
    this.actors.push(actor);
    return actor.time = this.time;
  };

  Timeline.prototype.advance = function() {
    var res;
    res = this.first();
    this.time = res.time;
    return res;
  };

  Timeline.prototype.first = function() {
    return _.min(this.actors, function(a) {
      return a.time;
    });
  };

  return Timeline;

})();

Stage = (function(_super) {
  __extends(Stage, _super);

  function Stage(mx, my, timeline) {
    var i;
    this.mx = mx;
    this.my = my;
    this.timeline = timeline;
    this.grid = (function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.mx * this.my; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(new Cell());
      }
      return _results;
    }).call(this);
    if (this.timeline == null) {
      this.timeline = new Timeline;
    }
  }

  Stage.prototype.at = function(x, y) {
    if (!this.isInside(x, y)) {
      return null;
    } else {
      return this.grid[y * this.mx + x];
    }
  };

  Stage.prototype.placeMob = function(_arg, mob) {
    var x, y;
    x = _arg.x, y = _arg.y;
    mob.setPos(this, x, y);
    this.at(x, y).mob = mob;
    return this.timeline.add(mob);
  };

  Stage.prototype.copy = function() {
    var c, res;
    res = new Stage(this.mx, this.my, this.timeline);
    res.grid = (function() {
      var _i, _len, _ref, _results;
      _ref = this.grid;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        _results.push(c.copy());
      }
      return _results;
    }).call(this);
    return res;
  };

  return Stage;

})(RegionTraits);

Region = (function(_super) {
  __extends(Region, _super);

  function Region(parent, xs, ys, mx, my) {
    this.parent = parent;
    this.xs = xs;
    this.ys = ys;
    this.mx = mx;
    this.my = my;
  }

  Region.prototype.at = function(x, y) {
    if (!this.isInside(x, y)) {
      return null;
    } else {
      return this.parent.at(this.xs + x, this.ys + y);
    }
  };

  Region.prototype.placeMob = function(xy, mob) {
    return this.stage().placeMob(this.pointToStage(xy), mob);
  };

  Region.prototype.pointToParent = function(_arg) {
    var x, y;
    x = _arg.x, y = _arg.y;
    return {
      x: x + this.xs,
      y: y + this.ys
    };
  };

  Region.prototype.pointToStage = function(xy) {
    var fn, _ref;
    fn = (_ref = this.parent.pointToStage) != null ? _ref : function(x) {
      return x;
    };
    return fn(this.pointToParent(xy));
  };

  return Region;

})(RegionTraits);

Mob = (function() {
  function Mob(glyph) {
    this.glyph = glyph;
    this.id = nextId();
  }

  Mob.prototype.setPos = function(stage, x, y) {
    this.stage = stage;
    this.x = x;
    return this.y = y;
  };

  Mob.prototype.speedFactor = function() {
    return 100 / this.speed;
  };

  Mob.prototype.cell = function() {
    return this.stage.at(this.x, this.y);
  };

  Mob.prototype.moveTo = function(_arg) {
    var action, x, y;
    x = _arg.x, y = _arg.y;
    action = {
      type: 'move',
      who: this,
      from: {
        x: this.x,
        y: this.y
      },
      to: {
        x: x,
        y: y
      }
    };
    this.cell().mob = null;
    this.x = x;
    this.y = y;
    this.stage.at(this.x, this.y).mob = this;
    return action;
  };

  Mob.prototype.toString = function() {
    return this.glyph;
  };

  return Mob;

})();

randomMob = function() {
  var m, speed, x;
  speed = randomBetween(50, 500);
  x = Math.round((speed - 50) / 450 * 8);
  m = new Mob('ABCDEFGHI'.charAt(x));
  m.speed = speed;
  return m;
};

setup = function() {
  var inside, map;
  map = new Stage(25, 15);
  inside = map.insideArea();
  inside.iterate(function(c) {
    return c.terrain = Terrain.FLOOR;
  });
  repeat(20, function() {
    var mob, pt;
    pt = inside.randomPoint();
    mob = randomMob();
    if (inside.atPoint(pt).canEnter(mob)) {
      return inside.placeMob(pt, mob);
    }
  });
  return map;
};

process = function(tl, steps) {
  var actions, choice, choices, limit, loc, mob;
  limit = tl.time + steps;
  actions = [];
  while (tl.time < limit) {
    mob = tl.advance();
    choices = (function() {
      var _i, _len, _ref, _results;
      _ref = mob.stage.adjacent(mob);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        loc = _ref[_i];
        if (loc.cell.canEnter(mob)) {
          _results.push(loc);
        }
      }
      return _results;
    })();
    choice = randomOf(choices);
    if (choice != null) {
      actions.push(mob.moveTo(choice));
      mob.time += 100 * mob.speedFactor();
    }
  }
  return actions;
};

showMap = function(el, map) {
  return el.html("<span style='display:inline-block'>" + map.toString().replace(/\n/g, '<br>') + "</span>");
};

glyphSize = _.memoize(function(map) {
  return {
    x: $('#map span').width() / map.mx,
    y: $('#map span').height() / map.my
  };
}, (function(_this) {
  return function(map) {
    return 0;
  };
})(this));

onDone = null;

showActions = function(el, map, actions) {
  var glyph, glyphPos, h, tmp, w, work;
  glyph = function(g, ps) {
    return $("<div class=\"glyph\"></div>").appendTo(el).text(g).css(glyphPos(ps));
  };
  glyphPos = function(_arg) {
    var x, y;
    x = _arg.x, y = _arg.y;
    return {
      left: x * w + "px",
      top: y * h + "px"
    };
  };
  w = glyphSize(map).x;
  h = glyphSize(map).y;
  tmp = map.copy();
  work = function() {
    var a, back, front, k, moves, newPos, promises, seq, _i, _len, _name;
    moves = {};
    for (_i = 0, _len = actions.length; _i < _len; _i++) {
      a = actions[_i];
      if (moves[_name = a.who.id] == null) {
        moves[_name] = [];
      }
      moves[a.who.id].push(a);
    }
    promises = (function() {
      var _j, _len1, _results;
      _results = [];
      for (k in moves) {
        seq = moves[k];
        a = seq[0];
        back = glyph('.', a.from);
        front = glyph(a.who.glyph, a.from).addClass('front');
        for (_j = 0, _len1 = seq.length; _j < _len1; _j++) {
          a = seq[_j];
          newPos = glyphPos(a.to);
          front.animate(newPos, 100);
        }
        _results.push(front.promise());
      }
      return _results;
    })();
    return $.when.apply($, promises).then(function() {
      return showMap(el, tmp);
    });
  };
  if (onDone != null) {
    return onDone = onDone.then(work);
  } else {
    return onDone = work();
  }
};

$(function() {
  var map;
  $('#content').html("<div id=\"map\"></div>\n<button id=\"step\" style=\"vertical-align:top\">STEP</button>");
  map = setup();
  showMap($('#map'), map);
  return $('#step').click(function() {
    var go;
    go = function() {
      return showActions($('#map'), map, process(map.timeline, 100)).then(go);
    };
    return go();
  });
});
