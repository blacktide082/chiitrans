// Generated by CoffeeScript 1.7.1
var $c0, $gmap, ANIM_DURATION, ANIM_TRANSITION, Cell, Feature, INTERSECT_CHANCE, Item, Keys, Mob, MobGlyph, Mode, PointSet, Region, RegionTraits, Stage, Terrain, Timeline, allLoaded, animateMap, animateMobs, attempt, chance, clearTarget, coinflip, ctx, ctx0, distance, distance2, doorTile, drawLine, drawPoint, drawTarget, finishAnim, floorTile, handleInput, imgLoaded, isInt, itemTile, keyMap, loadImage, makeCorridor, makeRandomRoom, makeTrail, mobGlyphs, mobTile, mode, move, moveTarget, nextId, p, playerTile, point, pox, poy, prepareTiles, process, profile, quadrant, random, randomBetween, randomIn, randomMob, randomOf, raycast, repeat, selectTarget, setup, showMap, showMapTiles, showMobs, sign, th, tw, updateMap, updateTarget, viewHeight, viewWidth, wallTile, _id,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

random = function(x) {
  return Math.floor(Math.random() * x);
};

randomBetween = function(x, y) {
  return x + random(y - x + 1);
};

randomIn = function(x, y) {
  return x + random(y - x);
};

randomOf = function(a) {
  return a[random(a.length)];
};

chance = function(x) {
  return Math.random() < x;
};

coinflip = function() {
  return chance(1 / 2);
};

attempt = function(maxAttempts, fn) {
  var i, _i;
  for (i = _i = 0; 0 <= maxAttempts ? _i < maxAttempts : _i > maxAttempts; i = 0 <= maxAttempts ? ++_i : --_i) {
    if (fn(i)) {
      return true;
    }
  }
  return false;
};

repeat = function(n, fn) {
  var i, _i;
  for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
    fn(i);
  }
};

_id = 0;

nextId = function() {
  return ++_id;
};

point = function(x, y) {
  return {
    x: x,
    y: y
  };
};

distance = function(x0, y0, x1, y1) {
  var x, y;
  x = x1 - x0;
  y = y1 - y0;
  return Math.sqrt(x * x + y * y);
};

distance2 = function(x0, y0, x1, y1) {
  var x, y;
  x = x1 - x0;
  y = y1 - y0;
  return x * x + y * y;
};

isInt = function(n) {
  var d;
  d = n - Math.floor(n);
  return d <= 1e-3 || (1 - d) <= 1e-3;
};

drawLine = function(p0, p1) {
  var x0, x1, y0, y1;
  if (!((p0 != null) && (p1 != null))) {
    return;
  }
  x0 = p0.x * gx;
  y0 = p0.y * gy;
  x1 = p1.x * gx;
  y1 = p1.y * gy;
  ctx.strokeStyle = 'red';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x0, y0);
  ctx.lineTo(x1, y1);
  return ctx.stroke();
};

drawPoint = function(x, y) {
  x *= gx;
  y *= gy;
  ctx.fillStyle = 'blue';
  ctx.beginPath();
  ctx.arc(x, y, 1, 0, 2 * Math.PI);
  return ctx.fill();
};

raycast = function(sx, sy, fx, fy, radius, cb) {
  var cellx, celly, dx, dy, oldx, oldy, qx, qy, x, x0, x1, xx, y, y0, y1, yy, _i, _j;
  dx = fx - sx;
  dy = fy - sy;
  qx = dx / dy;
  qy = dy / dx;
  if (dx !== 0) {
    xx = Math.sqrt(radius * radius / (1 + qy * qy));
    if (dx < 0) {
      xx = -xx;
    }
    yy = xx * qy;
    fx = sx + xx;
    fy = sy + yy;
  } else {
    if (dy > 0) {
      fy = sy + radius;
    } else {
      fy = sy - radius;
    }
  }
  if (Math.abs(dx) > Math.abs(dy)) {
    x0 = dx > 0 ? Math.ceil(sx) : Math.floor(sx);
    x1 = dx > 0 ? Math.floor(fx) : Math.ceil(fx);
    oldx = x0;
    oldy = Math.floor(sy);
    for (x = _i = x0; x0 <= x1 ? _i <= x1 : _i >= x1; x = x0 <= x1 ? ++_i : --_i) {
      y = sy + (x - sx) * qy;
      cellx = dx > 0 ? x : x - 1;
      if (isInt(y)) {
        celly = dy > 0 ? Math.round(y) : Math.round(y) - 1;
      } else {
        celly = Math.floor(y);
        if (celly !== oldy) {
          if ((cb(point(oldx, celly))) === false) {
            return false;
          }
        }
      }
      if ((cb(point(cellx, celly))) === false) {
        return false;
      }
      oldx = cellx;
      oldy = celly;
    }
  } else {
    y0 = dy > 0 ? Math.ceil(sy) : Math.floor(sy);
    y1 = dy > 0 ? Math.floor(fy) : Math.ceil(fy);
    oldx = Math.floor(sx);
    oldy = y0;
    for (y = _j = y0; y0 <= y1 ? _j <= y1 : _j >= y1; y = y0 <= y1 ? ++_j : --_j) {
      x = sx + (y - sy) * qx;
      celly = dy > 0 ? y : y - 1;
      if (isInt(x)) {
        cellx = dx > 0 ? Math.round(x) : Math.round(x) - 1;
      } else {
        cellx = Math.floor(x);
        if (cellx !== oldx) {
          if ((cb(point(cellx, oldy))) === false) {
            return false;
          }
        }
      }
      if ((cb(point(cellx, celly))) === false) {
        return false;
      }
      oldx = cellx;
      oldy = celly;
    }
  }
  return true;
};

profile = function(id, fn) {
  var ctr, f, res, s, _ctr;
  s = _.now();
  _ctr = 0;
  ctr = function() {
    return _ctr += 1;
  };
  res = fn(ctr);
  f = _.now() - s;
  console.log("" + id + ": time=" + f + " ctr=" + _ctr);
  return res;
};

quadrant = function(x, y) {
  switch (false) {
    case !(x < 0):
      if (y < 0) {
        return 1;
      } else {
        return 2;
      }
      break;
    case !(x > 0):
      if (y <= 0) {
        return 0;
      } else {
        return 3;
      }
      break;
    default:
      switch (false) {
        case !(y < 0):
          return 1;
        case !(y > 0):
          return 3;
        default:
          return -1;
      }
  }
};

sign = function(x) {
  switch (false) {
    case !(x < 0):
      return -1;
    case !(x > 0):
      return 1;
    default:
      return 0;
  }
};

Terrain = {
  FLOOR: 0,
  WALL: 1,
  DOOR: 2,
  WATER: 3
};

Feature = {
  BLOODY: 0
};

Keys = {
  LU: 36,
  UP: 38,
  RU: 33,
  LEFT: 37,
  RIGHT: 39,
  LD: 35,
  DOWN: 40,
  RD: 34,
  SPACE: 32,
  1: 49,
  TAB: 9,
  ENTER: 13,
  ESC: 27
};

keyMap = (function() {
  var k, v, _keyMap;
  _keyMap = {
    LU: [-1, -1],
    UP: [0, -1],
    RU: [1, -1],
    LEFT: [-1, 0],
    RIGHT: [1, 0],
    LD: [-1, 1],
    DOWN: [0, 1],
    RD: [1, 1],
    SPACE: [0, 0]
  };
  keyMap = {};
  for (k in _keyMap) {
    v = _keyMap[k];
    keyMap[Keys[k]] = v;
  }
  return keyMap;
})();

INTERSECT_CHANCE = 1 / 8;

ANIM_DURATION = 150;

ANIM_TRANSITION = 'linear';

PointSet = (function() {
  function PointSet() {
    this.store = {};
  }

  PointSet.prototype.key = function(_arg) {
    var x, y;
    x = _arg.x, y = _arg.y;
    return "" + x + "," + y;
  };

  PointSet.prototype.add = function(pt) {
    var key;
    key = this.key(pt);
    if (this.store[key] != null) {
      return false;
    } else {
      this.store[key] = pt;
      return true;
    }
  };

  PointSet.prototype.has = function(pt) {
    return this.store[this.key(pt)] != null;
  };

  PointSet.prototype.toArray = function() {
    return _.values(this.store);
  };

  return PointSet;

})();

Cell = (function() {
  function Cell() {
    this.terrain = Terrain.WALL;
  }

  Cell.prototype.canEnter = function(mob) {
    var _ref;
    return ((_ref = this.terrain) === Terrain.FLOOR || _ref === Terrain.DOOR) && (this.mob == null);
  };

  Cell.prototype.copy = function() {
    var res;
    res = new Cell;
    if (this.terrain != null) {
      res.terrain = this.terrain;
    }
    if (this.mob != null) {
      res.mob = this.mob;
    }
    return res;
  };

  Cell.prototype.isOpaque = function() {
    var _ref;
    return (_ref = this.terrain) === Terrain.WALL || _ref === Terrain.DOOR;
  };

  Cell.prototype.hasObstacle = function() {
    return this.isOpaque() || (this.mob != null);
  };

  Cell.prototype.terrainGlyph = function() {
    switch (this.terrain) {
      case Terrain.WALL:
        return '#';
      case Terrain.DOOR:
        return '+';
      case Terrain.WATER:
        return '~';
      default:
        return '.';
    }
  };

  Cell.prototype.isVisible = function() {
    return this.lastVisibleTime >= p.stage.timeline.time;
  };

  Cell.prototype.toString = function() {
    if (this.mob != null) {
      return this.mob.toString();
    } else if (this.item != null) {
      return this.item.toString();
    } else {
      return this.terrainGlyph();
    }
  };

  return Cell;

})();

RegionTraits = (function() {
  function RegionTraits() {}

  RegionTraits.prototype.isInside = function(x, y) {
    return (0 <= x && x < this.mx) && (0 <= y && y < this.my);
  };

  RegionTraits.prototype.randomPoint = function() {
    return {
      x: random(this.mx),
      y: random(this.my)
    };
  };

  RegionTraits.prototype.randomPointWhere = function(pred) {
    var c, i, res, _i;
    for (i = _i = 0; _i < 50; i = ++_i) {
      res = this.randomPoint();
      if (pred(this.atPoint(res), res.x, res.y)) {
        return res;
      }
    }
    return randomOf((function() {
      var _j, _len, _ref, _results;
      _ref = this.cells();
      _results = [];
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        c = _ref[_j];
        if (pred(c.cell, c.x, c.y)) {
          _results.push(c);
        }
      }
      return _results;
    }).call(this));
  };

  RegionTraits.prototype.insideArea = function(margin) {
    if (margin == null) {
      margin = 1;
    }
    return new Region(this, margin, margin, this.mx - margin * 2, this.my - margin * 2);
  };

  RegionTraits.prototype.iterate = function(fn) {
    var x, y, _i, _j, _ref, _ref1;
    for (y = _i = 0, _ref = this.my; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
      for (x = _j = 0, _ref1 = this.mx; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
        fn(this.at(x, y), x, y);
      }
    }
  };

  RegionTraits.prototype.cells = function() {
    var res;
    res = [];
    this.iterate(function(c, x, y) {
      return res.push({
        cell: c,
        x: x,
        y: y
      });
    });
    return res;
  };

  RegionTraits.prototype.stage = function() {
    var _ref, _ref1;
    return (_ref = (_ref1 = this.parent) != null ? _ref1.stage() : void 0) != null ? _ref : this;
  };

  RegionTraits.prototype.adjacent = function(_arg, radius) {
    var res, x, xx, y, yy, _i, _j, _ref, _ref1, _ref2, _ref3;
    x = _arg.x, y = _arg.y;
    if (radius == null) {
      radius = 1;
    }
    res = [];
    for (yy = _i = _ref = y - radius, _ref1 = y + radius; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; yy = _ref <= _ref1 ? ++_i : --_i) {
      for (xx = _j = _ref2 = x - radius, _ref3 = x + radius; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; xx = _ref2 <= _ref3 ? ++_j : --_j) {
        if (!(x === xx && y === yy) && this.isInside(xx, yy)) {
          res.push({
            cell: this.at(xx, yy),
            x: xx,
            y: yy
          });
        }
      }
    }
    return res;
  };

  RegionTraits.prototype.atPoint = function(_arg) {
    var x, y;
    x = _arg.x, y = _arg.y;
    return this.at(x, y);
  };

  return RegionTraits;

})();

Timeline = (function() {
  function Timeline() {
    this.time = 0;
    this.actors = [];
  }

  Timeline.prototype.add = function(actor) {
    this.actors.push(actor);
    return actor.time = this.time;
  };

  Timeline.prototype.remove = function(actor) {
    return this.actors = _.without(this.actors, actor);
  };

  Timeline.prototype.advance = function() {
    var res;
    res = this.first();
    this.time = res.time;
    return res;
  };

  Timeline.prototype.first = function() {
    return _.min(this.actors, function(a) {
      return a.time;
    });
  };

  return Timeline;

})();

Stage = (function(_super) {
  __extends(Stage, _super);

  function Stage(mx, my, timeline) {
    var i;
    this.mx = mx;
    this.my = my;
    this.timeline = timeline;
    this.grid = (function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.mx * this.my; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(new Cell());
      }
      return _results;
    }).call(this);
    if (this.timeline == null) {
      this.timeline = new Timeline;
    }
  }

  Stage.prototype.at = function(x, y) {
    if (!this.isInside(x, y)) {
      return null;
    } else {
      return this.grid[y * this.mx + x];
    }
  };

  Stage.prototype.placeMob = function(_arg, mob) {
    var x, y;
    x = _arg.x, y = _arg.y;
    mob.setPos(this, x, y);
    this.at(x, y).mob = mob;
    return this.timeline.add(mob);
  };

  Stage.prototype.removeMob = function(mob) {
    mob.cell().mob = null;
    if (mob !== p) {
      return this.timeline.remove(mob);
    }
  };

  Stage.prototype.copy = function() {
    var c, res;
    res = new Stage(this.mx, this.my, this.timeline);
    res.grid = (function() {
      var _i, _len, _ref, _results;
      _ref = this.grid;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        _results.push(c.copy());
      }
      return _results;
    }).call(this);
    return res;
  };

  Stage.prototype.updateVisibility = function(_arg, radius) {
    var ctr, fx, fy, go, ox, oy, queue, seen, sx, sy, time, xx, yy, _ref;
    ox = _arg.x, oy = _arg.y;
    go = function(pt) {
      if (seen.add(pt)) {
        queue.push(pt);
      }
    };
    time = this.timeline.time;
    this.at(ox, oy).lastVisibleTime = time;
    sx = ox + 0.5;
    sy = oy + 0.5;
    xx = ox;
    yy = oy;
    ctr = 0;
    seen = new PointSet();
    queue = [];
    queue.push(point(sx + 1, sy));
    while (queue.length > 0) {
      if (ctr++ > 1000) {
        throw new Error("infloop!");
        break;
      }
      _ref = queue.pop(), fx = _ref.x, fy = _ref.y;
      raycast(sx, sy, fx, fy, radius, (function(_this) {
        return function(_arg1) {
          var cell, x, y;
          x = _arg1.x, y = _arg1.y;
          xx = x;
          yy = y;
          cell = _this.at(x, y);
          if (cell == null) {
            console.log("BAD: " + x + " " + y);
            return false;
          }
          cell.lastVisibleTime = time;
          return !cell.isOpaque();
        };
      })(this));
      if (xx > ox && yy <= oy || xx <= ox && yy > oy) {
        go(point(xx, yy));
      }
      if (xx < ox && yy <= oy || xx >= ox && yy > oy) {
        go(point(xx + 1, yy));
      }
      if (xx <= ox && yy < oy || xx > ox && yy >= oy) {
        go(point(xx, yy + 1));
      }
      if (xx >= ox && yy < oy || xx < ox && yy >= oy) {
        go(point(xx + 1, yy + 1));
      }
    }
  };

  Stage.prototype.getBorderCells = function(_arg, radius) {
    var been, cell, dist, go, ox, oy, pt, queue, res, x, y, _i, _len, _ref, _ref1, _ref2;
    ox = _arg.x, oy = _arg.y;
    go = (function(_this) {
      return function(x, y, dist) {
        if (!been.has(point(x, y))) {
          been.add(point(x, y));
          if (dist < radius) {
            return queue.push({
              pt: point(x, y),
              dist: dist
            });
          }
        }
      };
    })(this);
    res = new PointSet;
    been = new PointSet;
    queue = [];
    go(ox, oy, 0);
    while (queue.length > 0) {
      _ref = queue.shift(), pt = _ref.pt, dist = _ref.dist;
      _ref1 = this.adjacent(pt);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        _ref2 = _ref1[_i], cell = _ref2.cell, x = _ref2.x, y = _ref2.y;
        if (cell.isOpaque()) {
          res.add(point(x, y));
        } else {
          go(x, y, dist + 1);
        }
      }
    }
    return res.toArray();
  };

  Stage.prototype.checkLOS = function(_arg, _arg1, radius, isPassable) {
    var fx, fy, i, j, saw, sx, sy, _i, _j;
    sx = _arg.x, sy = _arg.y;
    fx = _arg1.x, fy = _arg1.y;
    if (distance2(sx, sy, fx, fy) > radius * radius) {
      return false;
    } else {
      saw = false;
      for (i = _i = 0; _i <= 1; i = ++_i) {
        for (j = _j = 0; _j <= 1; j = ++_j) {
          raycast(sx + 0.5, sy + 0.5, fx + i, fy + j, radius, (function(_this) {
            return function(_arg2) {
              var c, x, y;
              x = _arg2.x, y = _arg2.y;
              if (x === fx && y === fy) {
                saw = true;
                return false;
              } else {
                c = _this.at(x, y);
                if ((c == null) || !isPassable(c)) {
                  return false;
                } else {
                  return true;
                }
              }
            };
          })(this));
          if (saw) {
            return true;
          }
        }
      }
      return false;
    }
  };

  Stage.prototype.toString = function() {
    var x, y;
    return ((function() {
      var _i, _ref, _results;
      _results = [];
      for (y = _i = 0, _ref = this.my; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        _results.push(((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (x = _j = 0, _ref1 = this.mx; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
            _results1.push(this.grid[y * this.mx + x].toString());
          }
          return _results1;
        }).call(this)).join(''));
      }
      return _results;
    }).call(this)).join('\n');
  };

  return Stage;

})(RegionTraits);

Region = (function(_super) {
  __extends(Region, _super);

  function Region(parent, xs, ys, mx, my) {
    this.parent = parent;
    this.xs = xs;
    this.ys = ys;
    this.mx = mx;
    this.my = my;
  }

  Region.prototype.at = function(x, y) {
    if (!this.isInside(x, y)) {
      return null;
    } else {
      return this.parent.at(this.xs + x, this.ys + y);
    }
  };

  Region.prototype.placeMob = function(xy, mob) {
    return this.stage().placeMob(this.pointToStage(xy), mob);
  };

  Region.prototype.pointToParent = function(_arg) {
    var x, y;
    x = _arg.x, y = _arg.y;
    return {
      x: x + this.xs,
      y: y + this.ys
    };
  };

  Region.prototype.pointToStage = function(xy) {
    var fn, _ref;
    fn = (_ref = this.parent.pointToStage) != null ? _ref : function(x) {
      return x;
    };
    return fn(this.pointToParent(xy));
  };

  return Region;

})(RegionTraits);

Mob = (function() {
  function Mob(glyph) {
    this.glyph = glyph;
    this.id = nextId();
    this.alive = true;
    this.kills = 0;
  }

  Mob.prototype.setPos = function(stage, x, y) {
    this.stage = stage;
    this.x = x;
    return this.y = y;
  };

  Mob.prototype.speedFactor = function() {
    return 100 / this.speed;
  };

  Mob.prototype.cell = function() {
    return this.stage.at(this.x, this.y);
  };

  Mob.prototype.moveTo = function(_arg) {
    var action, x, y;
    x = _arg.x, y = _arg.y;
    action = {
      type: 'move',
      who: this,
      from: {
        x: this.x,
        y: this.y
      },
      to: {
        x: x,
        y: y
      }
    };
    this.cell().mob = null;
    this.x = x;
    this.y = y;
    this.stage.at(this.x, this.y).mob = this;
    this.time += 100 * this.speedFactor();
    return action;
  };

  Mob.prototype.canSee = function(what) {
    return this.stage.checkLOS(this, what, this.visibilityRadius, function(c) {
      return !c.isOpaque();
    });
  };

  Mob.prototype.canShoot = function(what, radius) {
    return this.stage.checkLOS(this, what, radius, function(c) {
      return !c.hasObstacle();
    });
  };

  Mob.prototype.attack = function(other) {
    other.hp -= 10;
    if (other.hp <= 0) {
      other.die();
      this.kills += 1;
    }
    return this.time += 100;
  };

  Mob.prototype.wait = function() {
    return this.time += 100 * this.speedFactor();
  };

  Mob.prototype.die = function() {
    this.alive = false;
    this.stage.removeMob(this);
    return this.cell().feature = Feature.BLOODY;
  };

  Mob.prototype.targets = function(radius) {
    var l, locs, _i, _len, _results;
    locs = this.stage.adjacent(this, radius);
    _results = [];
    for (_i = 0, _len = locs.length; _i < _len; _i++) {
      l = locs[_i];
      if ((l.cell.mob != null) && this.canShoot(l.cell.mob, radius)) {
        _results.push(l.cell.mob);
      }
    }
    return _results;
  };

  Mob.prototype.toString = function() {
    return this.glyph;
  };

  return Mob;

})();

Item = (function() {
  function Item(glyph) {
    this.glyph = glyph;
    this.id = nextId();
  }

  Item.prototype.toString = function() {
    return this.glyph;
  };

  return Item;

})();

makeTrail = function(region, x, y, len, num) {
  var i, _i, _ref;
  for (i = _i = 0; 0 <= num ? _i < num : _i > num; i = 0 <= num ? ++_i : --_i) {
    _ref = makeCorridor(region, x, y, len), x = _ref.x, y = _ref.y;
  }
};

makeCorridor = function(region, x, y, len) {
  var dir, i, nx, ny, randomDir, _i;
  randomDir = function(z, mz) {
    var ch;
    ch = (0.5 + z / mz) * 0.5;
    if (chance(ch)) {
      return -1;
    } else {
      return 1;
    }
  };
  if (coinflip()) {
    dir = {
      x: 0,
      y: randomDir(y, region.my)
    };
  } else {
    dir = {
      x: randomDir(x, region.mx),
      y: 0
    };
  }
  if (dir.x === 0) {
    len = (Math.max(region.my / 8, 4)) | 0;
  } else {
    len = (Math.max(region.mx / 8, 4)) | 0;
  }
  len = randomBetween(len / 2 | 0, len);
  for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
    nx = x + dir.x;
    ny = y + dir.y;
    if (!region.isInside(nx, ny)) {
      break;
    }
    if (region.isInside(nx + dir.x, ny + dir.y) && region.at(nx + dir.x, ny + dir.y).terrain === Terrain.FLOOR && !chance(INTERSECT_CHANCE)) {
      break;
    }
    x = nx;
    y = ny;
    region.at(x, y).terrain = Terrain.FLOOR;
  }
  return point(x, y);
};

makeRandomRoom = function(region, maxWidth, maxHeight) {
  var isPassage, placeDoorLR, placeDoorUD, xd, yd;
  isPassage = function(x, y) {
    var _ref, _ref1;
    if ((_ref = (_ref1 = region.at(x, y)) != null ? _ref1.terrain : void 0) === Terrain.FLOOR || _ref === Terrain.DOOR || _ref === Terrain.WATER) {
      return 1;
    } else {
      return 0;
    }
  };
  placeDoorUD = function(x, y) {
    var _ref;
    if (((_ref = region.at(x, y)) != null ? _ref.terrain : void 0) === Terrain.FLOOR && !isPassage(x - 1, y) && !isPassage(x + 1, y)) {
      return region.at(x, y).terrain = Terrain.DOOR;
    }
  };
  placeDoorLR = function(x, y) {
    var _ref;
    if (((_ref = region.at(x, y)) != null ? _ref.terrain : void 0) === Terrain.FLOOR && !isPassage(x, y - 1) && !isPassage(x, y + 1)) {
      return region.at(x, y).terrain = Terrain.DOOR;
    }
  };
  xd = randomBetween(2, maxWidth);
  yd = randomBetween(2, maxHeight);
  return attempt(10, function() {
    var passages, x, xf, xs, y, yf, ys, _i, _j, _k, _l, _m, _n;
    xs = random(region.mx - xd + 1);
    ys = random(region.my - yd + 1);
    xf = xs + xd - 1;
    yf = ys + yd - 1;
    passages = 0;
    for (x = _i = xs; xs <= xf ? _i <= xf : _i >= xf; x = xs <= xf ? ++_i : --_i) {
      passages += isPassage(x, ys - 1);
      passages += isPassage(x, yf + 1);
    }
    for (y = _j = ys; ys <= yf ? _j <= yf : _j >= yf; y = ys <= yf ? ++_j : --_j) {
      passages += isPassage(xs - 1, y);
      passages += isPassage(xf + 1, y);
    }
    if (passages < 1 || passages > (3 + xd + yd) / 4) {
      return false;
    }
    for (x = _k = xs; xs <= xf ? _k <= xf : _k >= xf; x = xs <= xf ? ++_k : --_k) {
      for (y = _l = ys; ys <= yf ? _l <= yf : _l >= yf; y = ys <= yf ? ++_l : --_l) {
        region.at(x, y).terrain = Terrain.FLOOR;
      }
    }
    for (x = _m = xs; xs <= xf ? _m <= xf : _m >= xf; x = xs <= xf ? ++_m : --_m) {
      placeDoorUD(x, ys - 1);
      placeDoorUD(x, yf + 1);
    }
    for (y = _n = ys; ys <= yf ? _n <= yf : _n >= yf; y = ys <= yf ? ++_n : --_n) {
      placeDoorLR(xs - 1, y);
      placeDoorLR(xf + 1, y);
    }
    return true;
  });
};

randomMob = function() {
  var m;
  m = new Mob('A');
  m.speed = randomBetween(25, 200);
  m.hp = randomBetween(5, 25);
  m.visibilityRadius = 4;
  return m;
};

p = null;

setup = function() {
  var halfx, halfy, i, inside, map, mob, pt, startPoint, x, xx, y, yy, _i, _j, _k, _l, _m;
  map = new Stage(80, 35);
  inside = map.insideArea(1);
  halfx = inside.mx / 2 | 0;
  halfy = inside.my / 2 | 0;
  for (xx = _i = 0; _i <= 1; xx = ++_i) {
    for (yy = _j = 0; _j <= 1; yy = ++_j) {
      x = randomIn(halfx * xx, halfx * (xx + 1));
      y = randomIn(halfy * yy, halfy * (yy + 1));
      makeTrail(inside, x, y, 12, 100);
    }
  }
  for (i = _k = 1; _k <= 15; i = ++_k) {
    makeRandomRoom(inside, 10, 7);
  }
  for (i = _l = 1; _l <= 40; i = ++_l) {
    mob = randomMob();
    pt = inside.randomPointWhere((function(_this) {
      return function(c) {
        return c.canEnter(mob);
      };
    })(this));
    inside.placeMob(pt, mob);
  }
  for (i = _m = 1; _m <= 20; i = ++_m) {
    pt = map.randomPointWhere((function(_this) {
      return function(c) {
        return c.terrain === Terrain.FLOOR && (c.item == null);
      };
    })(this));
    map.atPoint(pt).item = new Item('$');
  }
  p = new Mob("@");
  p.speed = 100;
  p.hp = 100;
  p.visibilityRadius = 9;
  startPoint = inside.randomPointWhere((function(_this) {
    return function(c) {
      return c.canEnter(p);
    };
  })(this));
  inside.placeMob(startPoint, p);
  return map;
};

pox = poy = null;

updateMap = function() {
  var moves, pdx, pdy, _ref;
  moves = process();
  p.stage.updateVisibility(p, p.visibilityRadius);
  if (pox == null) {
    pox = p.x;
  }
  if (poy == null) {
    poy = p.y;
  }
  pdx = p.x - pox;
  pdy = p.y - poy;
  pox = p.x;
  poy = p.y;
  showMapTiles(pdx, pdy, moves);
  return $('#info').html("HP: " + p.hp + "/100<br>Kills: " + p.kills + "<br>Items: " + ((_ref = p.items) != null ? _ref : 0));
};

animateMap = function(pdx, pdy) {
  var completed, props;
  completed = $.Deferred();
  props = {
    duration: ANIM_DURATION,
    easing: ANIM_TRANSITION,
    complete: function() {
      $c0.css({
        x: 0,
        y: 0
      });
      completed.resolve();
    }
  };
  switch (false) {
    case !(pdx > 0):
      props.x = "-" + tw;
      break;
    case !(pdx < 0):
      props.x = "" + tw;
  }
  switch (false) {
    case !(pdy > 0):
      props.y = "-" + th;
      break;
    case !(pdy < 0):
      props.y = "" + th;
  }
  $c0.transition(props);
  return completed;
};

finishAnim = $.when(true);

showMapTiles = function(pdx, pdy, moves) {
  var before, h, mobsAnim, time, w, x0, x1, y0, y1;
  if (!(pdx === 0 && pdy === 0)) {
    before = animateMap(pdx, pdy);
  } else {
    before = true;
  }
  w = viewWidth + 2;
  h = viewHeight + 2;
  x0 = p.x - (w / 2 | 0);
  y0 = p.y - (h / 2 | 0);
  x1 = x0 + w - 1;
  y1 = y0 + h - 1;
  time = p.stage.timeline.time;
  $.when(before).then(function() {
    var cell, isVisible, tile, x, xx, y, yy, _i, _j;
    for (y = _i = y0; y0 <= y1 ? _i <= y1 : _i >= y1; y = y0 <= y1 ? ++_i : --_i) {
      for (x = _j = x0; x0 <= x1 ? _j <= x1 : _j >= x1; x = x0 <= x1 ? ++_j : --_j) {
        cell = p.stage.at(x, y);
        xx = (x - x0) * tw;
        yy = (y - y0) * th;
        if (cell != null) {
          if (cell.lastVisibleTime != null) {
            isVisible = cell.lastVisibleTime >= time;
            tile = (function() {
              switch (cell.terrain) {
                case Terrain.WALL:
                  return wallTile;
                case Terrain.DOOR:
                  return doorTile;
                default:
                  return floorTile;
              }
            })();
            ctx0.drawImage(tile, xx, yy);
            if (isVisible) {
              if (cell.item != null) {
                ctx0.drawImage(itemTile, xx, yy);
              }
            } else {
              ctx0.fillStyle = "rgba(0, 0, 0, 0.5)";
              ctx0.fillRect(xx, yy, tw, th);
            }
          } else {
            ctx0.fillStyle = '#000';
            ctx0.fillRect(xx, yy, tw, th);
          }
        } else {
          ctx0.fillStyle = '#000';
          ctx0.fillRect(xx, yy, tw, th);
        }
      }
    }
  });
  mobsAnim = animateMobs(moves);
  mobsAnim.then(function() {
    showMobs(x0 + 1, y0 + 1, x1 - 1, y1 - 1);
  });
  return finishAnim = $.when(before, mobsAnim);
};

MobGlyph = (function() {
  function MobGlyph(mob) {
    var _class;
    this.mob = mob;
    _class = this.mob === p ? "player" : "mob";
    this.glyph = $("<div class=\"glyph " + _class + "\"></div>");
    this.glyph.appendTo($gmap);
  }

  MobGlyph.prototype.updatePos = function() {
    var h, w, x0, y0;
    w = viewWidth;
    h = viewHeight;
    x0 = p.x - (w / 2 | 0);
    y0 = p.y - (h / 2 | 0);
    return this.glyph.css({
      x: (this.mob.x - x0) * tw,
      y: (this.mob.y - y0) * th
    });
  };

  MobGlyph.prototype.moveTo = function(_arg, effect) {
    var h, props, w, x, x0, y, y0;
    x = _arg.x, y = _arg.y;
    w = viewWidth;
    h = viewHeight;
    x0 = p.x - (w / 2 | 0);
    y0 = p.y - (h / 2 | 0);
    props = {
      x: (x - x0) * tw,
      y: (y - y0) * th,
      duration: ANIM_DURATION,
      easing: ANIM_TRANSITION
    };
    switch (effect) {
      case 'fadeIn':
        props.opacity = 0;
        break;
      case 'fadeOut':
        props.opacity = 1;
    }
    this.glyph.transition(props);
    return this.glyph.promise();
  };

  MobGlyph.prototype.remove = function() {
    this.mob = null;
    return this.glyph.remove();
  };

  return MobGlyph;

})();

mobGlyphs = {};

showMobs = function(x0, y0, x1, y1) {
  var cell, deleteIds, g, id, mobGlyph, x, y, _i, _j, _k, _len, _name;
  for (y = _i = y0; y0 <= y1 ? _i <= y1 : _i >= y1; y = y0 <= y1 ? ++_i : --_i) {
    for (x = _j = x0; x0 <= x1 ? _j <= x1 : _j >= x1; x = x0 <= x1 ? ++_j : --_j) {
      cell = p.stage.at(x, y);
      if ((cell != null) && cell.isVisible() && (cell.mob != null)) {
        mobGlyph = mobGlyphs[_name = cell.mob.id] != null ? mobGlyphs[_name] : mobGlyphs[_name] = new MobGlyph(cell.mob);
        mobGlyph.updatePos();
      }
    }
  }
  deleteIds = [];
  for (id in mobGlyphs) {
    g = mobGlyphs[id];
    if (!g.mob.alive || !g.mob.cell().isVisible()) {
      g.remove();
      deleteIds.push(id);
    }
  }
  for (_k = 0, _len = deleteIds.length; _k < _len; _k++) {
    id = deleteIds[_k];
    delete mobGlyphs[id];
  }
};

animateMobs = function(moves) {
  var animDone, effect, g, id, mobGlyph, mobId, move, promises, visAfter, visBefore, visDone, _i, _len;
  animDone = {};
  visDone = {};
  promises = [];
  for (_i = 0, _len = moves.length; _i < _len; _i++) {
    move = moves[_i];
    mobId = move.who.id;
    mobGlyph = mobGlyphs[mobId];
    if (mobGlyph != null) {
      visBefore = !animDone[mobId] || p.stage.atPoint(move.from).isVisible();
      visAfter = p.stage.atPoint(move.to).isVisible();
      effect = (function() {
        switch (false) {
          case !(visBefore && !visAfter):
            return 'fadeIn';
          case !(!visBefore && visAfter):
            return 'fadeOut';
          default:
            return '';
        }
      })();
      promises.push(mobGlyph.moveTo(move.to, effect));
      animDone[mobId] = true;
    }
  }
  for (id in mobGlyphs) {
    g = mobGlyphs[id];
    if (!animDone[id]) {
      promises.push(g.moveTo(g.mob));
    }
  }
  return $.when.apply($, promises);
};

showMap = function(el, map) {
  var buf, bufClass, cell, glyph, glyphClass, res, time, x, y, _i, _j, _ref, _ref1;
  res = $('<span>');
  time = map.timeline.time;
  buf = [];
  bufClass = null;
  for (y = _i = 0, _ref = map.my; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
    for (x = _j = 0, _ref1 = map.mx; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
      cell = map.at(x, y);
      if (cell.lastVisibleTime != null) {
        if (cell.lastVisibleTime < time) {
          glyph = cell.terrainGlyph();
          glyphClass = 'fog';
        } else {
          glyph = cell.toString();
          glyphClass = 'normal';
        }
        if (cell.feature === Feature.BLOODY && (cell.mob == null)) {
          glyphClass += ' bloody';
        }
      } else {
        glyph = '&nbsp;';
        glyphClass = 'unseen';
      }
      if (bufClass !== glyphClass) {
        if (bufClass !== null) {
          res.append("<span class=\"" + bufClass + "\">" + (buf.join('')) + "</span>");
        }
        buf = [glyph];
        bufClass = glyphClass;
      } else {
        buf.push(glyph);
      }
    }
    buf.push("<br/>");
  }
  res.append("<span class=\"" + bufClass + "\">" + (buf.join('')) + "</span>");
  return el.html(res);
};

move = function(dx, dy) {
  var c, grabItem, nx, ny;
  grabItem = function() {
    if (p.hp < 100 && (p.cell().item != null)) {
      if (p.items == null) {
        p.items = 0;
      }
      p.items += 1;
      p.cell().item = null;
      p.hp += 25;
      if (p.hp > 100) {
        return p.hp = 100;
      }
    }
  };
  if (!p.alive) {
    p.wait();
    grabItem();
    return true;
  }
  if (dx === 0 && dy === 0) {
    p.wait();
    return true;
  } else {
    nx = p.x + dx;
    ny = p.y + dy;
    c = p.stage.at(nx, ny);
    if (c.mob != null) {
      p.attack(c.mob);
      return true;
    } else {
      if (c.canEnter(p)) {
        p.moveTo(point(nx, ny));
        grabItem();
        return true;
      } else {
        return false;
      }
    }
  }
};

process = function() {
  var choice, choices, ctr, loc, mob, moves, tl;
  tl = p.stage.timeline;
  ctr = 0;
  moves = [];
  while (true) {
    if (ctr++ > 1000) {
      throw new Error("infloop in process");
    }
    mob = tl.advance();
    if (mob === p) {
      break;
    }
    choices = (function() {
      var _i, _len, _ref, _results;
      _ref = mob.stage.adjacent(mob);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        loc = _ref[_i];
        if (loc.cell.mob === p || loc.cell.canEnter(mob)) {
          _results.push(loc);
        }
      }
      return _results;
    })();
    if (mob.canSee(p)) {
      choice = _.min(choices, (function(_this) {
        return function(c) {
          return distance2(p.x, p.y, c.x, c.y);
        };
      })(this));
    } else {
      choice = randomOf(choices);
    }
    if (choice != null) {
      if (choice.cell.mob != null) {
        mob.attack(choice.cell.mob);
      } else {
        moves.push(mob.moveTo(choice));
      }
    } else {
      mob.wait();
    }
  }
  return moves;
};

updateTarget = function() {
  var targets;
  if (!((p.target != null) && p.target.alive && p.canShoot(p.target, 8))) {
    targets = p.targets(8);
    if (targets.length === 0) {
      return false;
    }
    p.target = _.min(targets, function(t) {
      return distance2(t.x, t.y, p.x, p.y);
    });
  }
  clearTarget();
  drawTarget();
  return true;
};

moveTarget = function(dx, dy) {
  var old, t, targets;
  old = p.target;
  targets = (function() {
    var _i, _len, _ref, _results;
    _ref = p.targets(8);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      t = _ref[_i];
      if ((dx === 0 || sign(t.x - old.x) === dx) && (dy === 0 || sign(t.y - old.y) === dy)) {
        _results.push(t);
      }
    }
    return _results;
  })();
  if (targets.length === 0) {
    return false;
  }
  p.target = _.min(targets, function(t) {
    return distance2(t.x, t.y, old.x, old.y);
  });
  return updateTarget();
};

clearTarget = function() {
  return ctx.clear();
};

selectTarget = function() {
  clearTarget();
  if (p.target != null) {
    p.attack(p.target);
    return true;
  } else {
    return false;
  }
};

drawTarget = function() {
  var h, w, x, x0, y, y0;
  w = viewWidth;
  h = viewHeight;
  x0 = p.x - (w / 2 | 0);
  y0 = p.y - (h / 2 | 0);
  x = tw * (p.target.x - x0 + 0.5) + 1;
  y = th * (p.target.y - y0 + 0.5) + 1;
  ctx.strokeStyle = '#00ff00';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x, y, tw / 2, 0, 2 * Math.PI);
  return ctx.stroke();
};

ctx = null;

Mode = {
  NORMAL: 0,
  TARGETING: 1
};

mode = Mode.NORMAL;

loadImage = function(src) {
  var res;
  res = new Image();
  res.src = 'res/' + src;
  res.onload = imgLoaded;
  return res;
};

$gmap = null;

$c0 = null;

ctx0 = null;

tw = 32;

th = 32;

viewWidth = 25;

viewHeight = 19;

allLoaded = $.Deferred();

imgLoaded = function() {
  return allLoaded.resolve();
};

imgLoaded = _.after(6, imgLoaded);

floorTile = loadImage('tiles/floor.png');

wallTile = loadImage('tiles/wall.png');

playerTile = loadImage('tiles/player.png');

mobTile = loadImage('tiles/mob.png');

itemTile = loadImage('tiles/item.png');

doorTile = loadImage('tiles/door.png');

prepareTiles = function() {
  var $c, h, w;
  $gmap = $('#gmap');
  $gmap.css({
    width: viewWidth * tw,
    height: viewHeight * th
  });
  $c0 = $("<canvas>").appendTo($gmap);
  $c0.css({
    left: (-tw) + "px",
    top: (-th) + "px"
  });
  w = (viewWidth + 2) * tw;
  h = (viewHeight + 2) * th;
  $c0.prop({
    width: w,
    height: h
  });
  ctx0 = $c0[0].getContext('2d');
  ctx0.clear = function() {
    return $c0[0].width = $c0[0].width;
  };
  $c = $("<canvas>").appendTo($gmap);
  $c.css('z-index', 10);
  $c.prop({
    width: viewWidth * tw,
    height: viewHeight * th
  });
  ctx = $c[0].getContext('2d');
  return ctx.clear = function() {
    return $c[0].width = $c[0].width;
  };
};

handleInput = function(e) {
  var dx, dy, _ref, _ref1;
  switch (mode) {
    case Mode.NORMAL:
      if (keyMap[e.which] != null) {
        _ref = keyMap[e.which], dx = _ref[0], dy = _ref[1];
        if (move(dx, dy)) {
          updateMap();
        }
        return false;
      } else {
        switch (e.which) {
          case Keys[1]:
            if (updateTarget()) {
              mode = Mode.TARGETING;
            }
            return false;
        }
      }
      break;
    case Mode.TARGETING:
      if (keyMap[e.which] != null) {
        _ref1 = keyMap[e.which], dx = _ref1[0], dy = _ref1[1];
        moveTarget(dx, dy);
        return false;
      } else {
        switch (e.which) {
          case Keys.ENTER:
            if (selectTarget()) {
              updateMap(0, 0);
            }
            mode = Mode.NORMAL;
            return false;
          case Keys.ESC:
            clearTarget();
            mode = Mode.NORMAL;
            return false;
        }
      }
  }
};

$(function() {
  var haveJob, map, savedKey;
  $('#content').html("<div id=\"gmap\" class=\"graphics\"></div>\n<div id=\"info\"></div>\n<button id=\"test\">test</button>\n<!--<canvas id=\"c\" width=1024 height=800></canvas>-->");
  map = setup();
  prepareTiles();
  savedKey = null;
  haveJob = false;
  return allLoaded.done(function() {
    var processInput;
    updateMap(0, 0);
    $(document).keydown(function(e) {
      savedKey = e;
      return processInput();
    }).keyup(function() {
      return savedKey = null;
    });
    return processInput = function() {
      var res;
      if (savedKey !== null) {
        if (finishAnim.state() === "resolved") {
          res = handleInput(savedKey);
        } else {
          res = false;
        }
        if (!haveJob && finishAnim.state() === "pending") {
          haveJob = true;
          finishAnim.then(function() {
            haveJob = false;
            return processInput();
          });
        }
        return res;
      }
    };
  });
});
