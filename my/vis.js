// Generated by CoffeeScript 1.7.1
var Cell, Feature, INTERSECT_CHANCE, Item, Keys, Mob, PointSet, Region, RegionTraits, Stage, Terrain, Timeline, attempt, chance, coinflip, distance, distance2, isInt, keyMap, makeCorridor, makeRandomRoom, makeTrail, move, nextId, p, point, process, profile, quadrant, random, randomBetween, randomIn, randomMob, randomOf, raycast, repeat, setup, showMap, updateMap, _id,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

random = function(x) {
  return Math.floor(Math.random() * x);
};

randomBetween = function(x, y) {
  return x + random(y - x + 1);
};

randomIn = function(x, y) {
  return x + random(y - x);
};

randomOf = function(a) {
  return a[random(a.length)];
};

chance = function(x) {
  return Math.random() < x;
};

coinflip = function() {
  return chance(1 / 2);
};

attempt = function(maxAttempts, fn) {
  var i, _i;
  for (i = _i = 0; 0 <= maxAttempts ? _i < maxAttempts : _i > maxAttempts; i = 0 <= maxAttempts ? ++_i : --_i) {
    if (fn(i)) {
      return true;
    }
  }
  return false;
};

repeat = function(n, fn) {
  var i, _i;
  for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
    fn(i);
  }
};

_id = 0;

nextId = function() {
  return ++_id;
};

point = function(x, y) {
  return {
    x: x,
    y: y
  };
};

distance = function(x0, y0, x1, y1) {
  var x, y;
  x = x1 - x0;
  y = y1 - y0;
  return Math.sqrt(x * x + y * y);
};

distance2 = function(x0, y0, x1, y1) {
  var x, y;
  x = x1 - x0;
  y = y1 - y0;
  return x * x + y * y;
};

isInt = function(n) {
  var d;
  d = n - Math.floor(n);
  return d <= 1e-3 || (1 - d) <= 1e-3;
};

raycast = function(sx, sy, fx, fy, radius, cb) {
  var badResult, badqx, badqy, been, ctr, d1, d2, dx, dy, endPoint, ok, okUser, p1, p2, qx, qy, radius2, stepx, stepy, sxx, syy, x_for_y, xx, y_for_x, yy, _ref, _ref1, _ref2, _ref3;
  radius2 = radius * radius + 0.1;
  badResult = [null, radius2 + 1];
  y_for_x = function(x) {
    return sy + (x - sx) * qy;
  };
  x_for_y = function(y) {
    return sx + (y - sy) * qx;
  };
  stepx = function() {
    var ix, iy, y;
    if (badqy) {
      return badResult;
    } else {
      while (true) {
        xx += dx;
        y = y_for_x(xx);
        if (!(isInt(xx) && isInt(y))) {
          break;
        }
      }
      ix = Math.floor(xx);
      iy = Math.floor(y);
      return [point(ix, iy), distance2(sx, sy, xx, y)];
    }
  };
  stepy = function() {
    var ix, iy, x;
    if (badqx) {
      return badResult;
    } else {
      while (true) {
        yy += dy;
        x = x_for_y(yy);
        if (!(isInt(x) && isInt(yy))) {
          break;
        }
      }
      ix = Math.floor(x);
      iy = Math.floor(yy);
      return [point(ix, iy), distance2(sx, sy, x, yy)];
    }
  };
  qx = (fx - sx) / (fy - sy);
  qy = 1 / qx;
  badqx = !_.isFinite(qx);
  badqy = !_.isFinite(qy);
  sxx = Math.floor(sx);
  syy = Math.floor(sy);
  xx = sx;
  yy = sy;
  dx = fx > sx ? 0.5 : -0.5;
  dy = fy > sy ? 0.5 : -0.5;
  been = new PointSet;
  been.add(point(sxx, syy));
  _ref = stepx(), p1 = _ref[0], d1 = _ref[1];
  _ref1 = stepy(), p2 = _ref1[0], d2 = _ref1[1];
  ok = true;
  okUser = true;
  ctr = 0;
  while (ok) {
    if (ctr++ > 1000) {
      throw new Error("raycast infinite loop!");
    }
    if (d1 <= d2) {
      if (d1 <= radius2) {
        if (been.add(p1)) {
          ok = okUser = cb(p1) !== false;
        }
        _ref2 = stepx(), p1 = _ref2[0], d1 = _ref2[1];
      } else {
        ok = false;
      }
    } else {
      if (d2 <= radius2) {
        if (been.add(p2)) {
          ok = okUser = cb(p2) !== false;
        }
        _ref3 = stepy(), p2 = _ref3[0], d2 = _ref3[1];
      } else {
        ok = false;
      }
    }
  }
  if (okUser && !badqx && !badqy) {
    xx = Math.sqrt(radius * radius / (1 + qy * qy));
    if (fx < sx) {
      xx = -xx;
    }
    yy = xx * qy;
    endPoint = point(Math.floor(sx + xx), Math.floor(sy + yy));
    if (!been.has(endPoint)) {
      cb(endPoint);
    }
  }
};

profile = function(id, fn) {
  var ctr, f, res, s, _ctr;
  s = new Date().getTime();
  _ctr = 0;
  ctr = function() {
    return _ctr += 1;
  };
  res = fn(ctr);
  f = (new Date().getTime()) - s;
  console.log("" + id + ": time=" + f + " ctr=" + _ctr);
  return res;
};

quadrant = function(x, y) {
  switch (false) {
    case !(x < 0):
      if (y < 0) {
        return 1;
      } else {
        return 2;
      }
      break;
    case !(x > 0):
      if (y <= 0) {
        return 0;
      } else {
        return 3;
      }
      break;
    default:
      switch (false) {
        case !(y < 0):
          return 1;
        case !(y > 0):
          return 3;
        default:
          return -1;
      }
  }
};

Terrain = {
  FLOOR: 0,
  WALL: 1,
  DOOR: 2,
  WATER: 3
};

Feature = {
  BLOODY: 0
};

Keys = {
  LU: 36,
  UP: 38,
  RU: 33,
  LEFT: 37,
  RIGHT: 39,
  LD: 35,
  DOWN: 40,
  RD: 34,
  SPACE: 32
};

keyMap = (function() {
  var k, v, _keyMap;
  _keyMap = {
    LU: [-1, -1],
    UP: [0, -1],
    RU: [1, -1],
    LEFT: [-1, 0],
    RIGHT: [1, 0],
    LD: [-1, 1],
    DOWN: [0, 1],
    RD: [1, 1],
    SPACE: [0, 0]
  };
  keyMap = {};
  for (k in _keyMap) {
    v = _keyMap[k];
    keyMap[Keys[k]] = v;
  }
  return keyMap;
})();

INTERSECT_CHANCE = 1 / 8;

PointSet = (function() {
  function PointSet() {
    this.store = {};
  }

  PointSet.prototype.key = function(_arg) {
    var x, y;
    x = _arg.x, y = _arg.y;
    return "" + x + "," + y;
  };

  PointSet.prototype.add = function(pt) {
    var key;
    key = this.key(pt);
    if (this.store[key] != null) {
      return false;
    } else {
      this.store[key] = pt;
      return true;
    }
  };

  PointSet.prototype.has = function(pt) {
    return this.store[this.key(pt)] != null;
  };

  PointSet.prototype.toArray = function() {
    return _.values(this.store);
  };

  return PointSet;

})();

Cell = (function() {
  function Cell() {
    this.terrain = Terrain.WALL;
  }

  Cell.prototype.canEnter = function(mob) {
    var _ref;
    return ((_ref = this.terrain) === Terrain.FLOOR || _ref === Terrain.WATER || _ref === Terrain.DOOR) && (this.mob == null);
  };

  Cell.prototype.copy = function() {
    var res;
    res = new Cell;
    if (this.terrain != null) {
      res.terrain = this.terrain;
    }
    if (this.mob != null) {
      res.mob = this.mob;
    }
    return res;
  };

  Cell.prototype.isOpaque = function() {
    var _ref;
    return (_ref = this.terrain) === Terrain.WALL || _ref === Terrain.DOOR;
  };

  Cell.prototype.terrainGlyph = function() {
    switch (this.terrain) {
      case Terrain.WALL:
        return '#';
      case Terrain.DOOR:
        return '+';
      case Terrain.WATER:
        return '~';
      default:
        return '.';
    }
  };

  Cell.prototype.toString = function() {
    if (this.mob != null) {
      return this.mob.toString();
    } else if (this.item != null) {
      return this.item.toString();
    } else {
      return this.terrainGlyph();
    }
  };

  return Cell;

})();

RegionTraits = (function() {
  function RegionTraits() {}

  RegionTraits.prototype.isInside = function(x, y) {
    return (0 <= x && x < this.mx) && (0 <= y && y < this.my);
  };

  RegionTraits.prototype.randomPoint = function() {
    return {
      x: random(this.mx),
      y: random(this.my)
    };
  };

  RegionTraits.prototype.randomPointWhere = function(pred) {
    var c, i, res, _i;
    for (i = _i = 0; _i < 50; i = ++_i) {
      res = this.randomPoint();
      if (pred(this.atPoint(res), res.x, res.y)) {
        return res;
      }
    }
    return randomOf((function() {
      var _j, _len, _ref, _results;
      _ref = this.cells();
      _results = [];
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        c = _ref[_j];
        if (pred(c.cell, c.x, c.y)) {
          _results.push(c);
        }
      }
      return _results;
    }).call(this));
  };

  RegionTraits.prototype.insideArea = function(margin) {
    if (margin == null) {
      margin = 1;
    }
    return new Region(this, margin, margin, this.mx - margin * 2, this.my - margin * 2);
  };

  RegionTraits.prototype.iterate = function(fn) {
    var x, y, _i, _j, _ref, _ref1;
    for (y = _i = 0, _ref = this.my; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
      for (x = _j = 0, _ref1 = this.mx; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
        fn(this.at(x, y), x, y);
      }
    }
  };

  RegionTraits.prototype.cells = function() {
    var res;
    res = [];
    this.iterate(function(c, x, y) {
      return res.push({
        cell: c,
        x: x,
        y: y
      });
    });
    return res;
  };

  RegionTraits.prototype.stage = function() {
    var _ref, _ref1;
    return (_ref = (_ref1 = this.parent) != null ? _ref1.stage() : void 0) != null ? _ref : this;
  };

  RegionTraits.prototype.adjacent = function(_arg) {
    var res, x, xx, y, yy, _i, _j, _ref, _ref1, _ref2, _ref3;
    x = _arg.x, y = _arg.y;
    res = [];
    for (yy = _i = _ref = y - 1, _ref1 = y + 1; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; yy = _ref <= _ref1 ? ++_i : --_i) {
      for (xx = _j = _ref2 = x - 1, _ref3 = x + 1; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; xx = _ref2 <= _ref3 ? ++_j : --_j) {
        if (!(x === xx && y === yy) && this.isInside(xx, yy)) {
          res.push({
            cell: this.at(xx, yy),
            x: xx,
            y: yy
          });
        }
      }
    }
    return res;
  };

  RegionTraits.prototype.atPoint = function(_arg) {
    var x, y;
    x = _arg.x, y = _arg.y;
    return this.at(x, y);
  };

  return RegionTraits;

})();

Timeline = (function() {
  function Timeline() {
    this.time = 0;
    this.actors = [];
  }

  Timeline.prototype.add = function(actor) {
    this.actors.push(actor);
    return actor.time = this.time;
  };

  Timeline.prototype.remove = function(actor) {
    return this.actors = _.without(this.actors, actor);
  };

  Timeline.prototype.advance = function() {
    var res;
    res = this.first();
    this.time = res.time;
    return res;
  };

  Timeline.prototype.first = function() {
    return _.min(this.actors, function(a) {
      return a.time;
    });
  };

  return Timeline;

})();

Stage = (function(_super) {
  __extends(Stage, _super);

  function Stage(mx, my, timeline) {
    var i;
    this.mx = mx;
    this.my = my;
    this.timeline = timeline;
    this.grid = (function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.mx * this.my; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(new Cell());
      }
      return _results;
    }).call(this);
    if (this.timeline == null) {
      this.timeline = new Timeline;
    }
  }

  Stage.prototype.at = function(x, y) {
    if (!this.isInside(x, y)) {
      return null;
    } else {
      return this.grid[y * this.mx + x];
    }
  };

  Stage.prototype.placeMob = function(_arg, mob) {
    var x, y;
    x = _arg.x, y = _arg.y;
    mob.setPos(this, x, y);
    this.at(x, y).mob = mob;
    return this.timeline.add(mob);
  };

  Stage.prototype.removeMob = function(mob) {
    mob.cell().mob = null;
    if (mob !== p) {
      return this.timeline.remove(mob);
    }
  };

  Stage.prototype.copy = function() {
    var c, res;
    res = new Stage(this.mx, this.my, this.timeline);
    res.grid = (function() {
      var _i, _len, _ref, _results;
      _ref = this.grid;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        _results.push(c.copy());
      }
      return _results;
    }).call(this);
    return res;
  };

  Stage.prototype.updateVisibility = function(_arg, radius) {
    var ctr, fx, fy, go, ox, oy, queue, seen, sx, sy, time, xx, yy, _ref;
    ox = _arg.x, oy = _arg.y;
    go = function(pt) {
      if (seen.add(pt)) {
        queue.push(pt);
      }
    };
    time = this.timeline.time;
    this.at(ox, oy).lastVisibleTime = time;
    sx = ox + 0.5;
    sy = oy + 0.5;
    xx = ox;
    yy = oy;
    ctr = 0;
    seen = new PointSet();
    queue = [];
    queue.push(point(sx + 1, sy));
    while (queue.length > 0) {
      if (ctr++ > 1000) {
        throw new Error("infloop!");
        break;
      }
      _ref = queue.pop(), fx = _ref.x, fy = _ref.y;
      raycast(sx, sy, fx, fy, radius, (function(_this) {
        return function(_arg1) {
          var cell, x, y;
          x = _arg1.x, y = _arg1.y;
          xx = x;
          yy = y;
          cell = _this.at(x, y);
          if (cell == null) {
            console.log("BAD: " + x + " " + y);
            return false;
          }
          cell.lastVisibleTime = time;
          return !cell.isOpaque();
        };
      })(this));
      if (xx > ox && yy <= oy || xx <= ox && yy > oy) {
        go(point(xx, yy));
      }
      if (xx < ox && yy <= oy || xx >= ox && yy > oy) {
        go(point(xx + 1, yy));
      }
      if (xx <= ox && yy < oy || xx > ox && yy >= oy) {
        go(point(xx, yy + 1));
      }
      if (xx >= ox && yy < oy || xx < ox && yy >= oy) {
        go(point(xx + 1, yy + 1));
      }
    }
  };

  Stage.prototype.getBorderCells = function(_arg, radius) {
    var been, cell, dist, go, ox, oy, pt, queue, res, x, y, _i, _len, _ref, _ref1, _ref2;
    ox = _arg.x, oy = _arg.y;
    go = (function(_this) {
      return function(x, y, dist) {
        if (!been.has(point(x, y))) {
          been.add(point(x, y));
          if (dist < radius) {
            return queue.push({
              pt: point(x, y),
              dist: dist
            });
          }
        }
      };
    })(this);
    res = new PointSet;
    been = new PointSet;
    queue = [];
    go(ox, oy, 0);
    while (queue.length > 0) {
      _ref = queue.shift(), pt = _ref.pt, dist = _ref.dist;
      _ref1 = this.adjacent(pt);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        _ref2 = _ref1[_i], cell = _ref2.cell, x = _ref2.x, y = _ref2.y;
        if (cell.isOpaque()) {
          res.add(point(x, y));
        } else {
          go(x, y, dist + 1);
        }
      }
    }
    return res.toArray();
  };

  Stage.prototype.checkLOS = function(_arg, _arg1, radius) {
    var fx, fy, i, j, saw, sx, sy, _i, _j;
    sx = _arg.x, sy = _arg.y;
    fx = _arg1.x, fy = _arg1.y;
    if (distance2(sx, sy, fx, fy) > radius * radius) {
      return false;
    } else {
      saw = false;
      for (i = _i = 0; _i <= 1; i = ++_i) {
        for (j = _j = 0; _j <= 1; j = ++_j) {
          raycast(sx + 0.5, sy + 0.5, fx + i, fy + j, radius, (function(_this) {
            return function(_arg2) {
              var x, y;
              x = _arg2.x, y = _arg2.y;
              if (x === fx && y === fy) {
                saw = true;
                return false;
              } else if (_this.at(x, y).isOpaque()) {
                return false;
              } else {
                return true;
              }
            };
          })(this));
          if (saw) {
            return true;
          }
        }
      }
      return false;
    }
  };

  Stage.prototype.toString = function() {
    var x, y;
    return ((function() {
      var _i, _ref, _results;
      _results = [];
      for (y = _i = 0, _ref = this.my; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        _results.push(((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (x = _j = 0, _ref1 = this.mx; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
            _results1.push(this.grid[y * this.mx + x].toString());
          }
          return _results1;
        }).call(this)).join(''));
      }
      return _results;
    }).call(this)).join('\n');
  };

  return Stage;

})(RegionTraits);

Region = (function(_super) {
  __extends(Region, _super);

  function Region(parent, xs, ys, mx, my) {
    this.parent = parent;
    this.xs = xs;
    this.ys = ys;
    this.mx = mx;
    this.my = my;
  }

  Region.prototype.at = function(x, y) {
    if (!this.isInside(x, y)) {
      return null;
    } else {
      return this.parent.at(this.xs + x, this.ys + y);
    }
  };

  Region.prototype.placeMob = function(xy, mob) {
    return this.stage().placeMob(this.pointToStage(xy), mob);
  };

  Region.prototype.pointToParent = function(_arg) {
    var x, y;
    x = _arg.x, y = _arg.y;
    return {
      x: x + this.xs,
      y: y + this.ys
    };
  };

  Region.prototype.pointToStage = function(xy) {
    var fn, _ref;
    fn = (_ref = this.parent.pointToStage) != null ? _ref : function(x) {
      return x;
    };
    return fn(this.pointToParent(xy));
  };

  return Region;

})(RegionTraits);

Mob = (function() {
  function Mob(glyph) {
    this.glyph = glyph;
    this.id = nextId();
    this.alive = true;
    this.kills = 0;
  }

  Mob.prototype.setPos = function(stage, x, y) {
    this.stage = stage;
    this.x = x;
    return this.y = y;
  };

  Mob.prototype.speedFactor = function() {
    return 100 / this.speed;
  };

  Mob.prototype.cell = function() {
    return this.stage.at(this.x, this.y);
  };

  Mob.prototype.moveTo = function(_arg) {
    var action, x, y;
    x = _arg.x, y = _arg.y;
    action = {
      type: 'move',
      who: this,
      from: {
        x: this.x,
        y: this.y
      },
      to: {
        x: x,
        y: y
      }
    };
    this.cell().mob = null;
    this.x = x;
    this.y = y;
    this.stage.at(this.x, this.y).mob = this;
    this.time += 100 * this.speedFactor();
    return action;
  };

  Mob.prototype.canSee = function(what) {
    return this.stage.checkLOS(this, what, this.visibilityRadius);
  };

  Mob.prototype.attack = function(other) {
    other.hp -= 10;
    if (other.hp <= 0) {
      other.die();
      this.kills += 1;
    }
    return this.time += 100;
  };

  Mob.prototype.wait = function() {
    return this.time += 100 * this.speedFactor();
  };

  Mob.prototype.die = function() {
    this.alive = false;
    this.stage.removeMob(this);
    return this.cell().feature = Feature.BLOODY;
  };

  Mob.prototype.toString = function() {
    return this.glyph;
  };

  return Mob;

})();

Item = (function() {
  function Item(glyph) {
    this.glyph = glyph;
    this.id = nextId();
  }

  Item.prototype.toString = function() {
    return this.glyph;
  };

  return Item;

})();

makeTrail = function(region, x, y, len, num) {
  var i, _i, _ref;
  for (i = _i = 0; 0 <= num ? _i < num : _i > num; i = 0 <= num ? ++_i : --_i) {
    _ref = makeCorridor(region, x, y, len), x = _ref.x, y = _ref.y;
  }
};

makeCorridor = function(region, x, y, len) {
  var dir, i, nx, ny, randomDir, _i;
  randomDir = function(z, mz) {
    var ch;
    ch = (0.5 + z / mz) * 0.5;
    if (chance(ch)) {
      return -1;
    } else {
      return 1;
    }
  };
  if (coinflip()) {
    dir = {
      x: 0,
      y: randomDir(y, region.my)
    };
  } else {
    dir = {
      x: randomDir(x, region.mx),
      y: 0
    };
  }
  if (dir.x === 0) {
    len = (Math.max(region.my / 8, 4)) | 0;
  } else {
    len = (Math.max(region.mx / 8, 4)) | 0;
  }
  len = randomBetween(len / 2 | 0, len);
  for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
    nx = x + dir.x;
    ny = y + dir.y;
    if (!region.isInside(nx, ny)) {
      break;
    }
    if (region.isInside(nx + dir.x, ny + dir.y) && region.at(nx + dir.x, ny + dir.y).terrain === Terrain.FLOOR && !chance(INTERSECT_CHANCE)) {
      break;
    }
    x = nx;
    y = ny;
    region.at(x, y).terrain = Terrain.FLOOR;
  }
  return point(x, y);
};

makeRandomRoom = function(region, maxWidth, maxHeight) {
  var isPassage, placeDoorLR, placeDoorUD, xd, yd;
  isPassage = function(x, y) {
    var _ref, _ref1;
    if ((_ref = (_ref1 = region.at(x, y)) != null ? _ref1.terrain : void 0) === Terrain.FLOOR || _ref === Terrain.DOOR || _ref === Terrain.WATER) {
      return 1;
    } else {
      return 0;
    }
  };
  placeDoorUD = function(x, y) {
    var _ref;
    if (((_ref = region.at(x, y)) != null ? _ref.terrain : void 0) === Terrain.FLOOR && !isPassage(x - 1, y) && !isPassage(x + 1, y)) {
      return region.at(x, y).terrain = Terrain.DOOR;
    }
  };
  placeDoorLR = function(x, y) {
    var _ref;
    if (((_ref = region.at(x, y)) != null ? _ref.terrain : void 0) === Terrain.FLOOR && !isPassage(x, y - 1) && !isPassage(x, y + 1)) {
      return region.at(x, y).terrain = Terrain.DOOR;
    }
  };
  xd = randomBetween(2, maxWidth);
  yd = randomBetween(2, maxHeight);
  return attempt(10, function() {
    var passages, x, xf, xs, y, yf, ys, _i, _j, _k, _l, _m, _n;
    xs = random(region.mx - xd + 1);
    ys = random(region.my - yd + 1);
    xf = xs + xd - 1;
    yf = ys + yd - 1;
    passages = 0;
    for (x = _i = xs; xs <= xf ? _i <= xf : _i >= xf; x = xs <= xf ? ++_i : --_i) {
      passages += isPassage(x, ys - 1);
      passages += isPassage(x, yf + 1);
    }
    for (y = _j = ys; ys <= yf ? _j <= yf : _j >= yf; y = ys <= yf ? ++_j : --_j) {
      passages += isPassage(xs - 1, y);
      passages += isPassage(xf + 1, y);
    }
    if (passages < 1 || passages > (3 + xd + yd) / 4) {
      return false;
    }
    for (x = _k = xs; xs <= xf ? _k <= xf : _k >= xf; x = xs <= xf ? ++_k : --_k) {
      for (y = _l = ys; ys <= yf ? _l <= yf : _l >= yf; y = ys <= yf ? ++_l : --_l) {
        region.at(x, y).terrain = Terrain.FLOOR;
      }
    }
    for (x = _m = xs; xs <= xf ? _m <= xf : _m >= xf; x = xs <= xf ? ++_m : --_m) {
      placeDoorUD(x, ys - 1);
      placeDoorUD(x, yf + 1);
    }
    for (y = _n = ys; ys <= yf ? _n <= yf : _n >= yf; y = ys <= yf ? ++_n : --_n) {
      placeDoorLR(xs - 1, y);
      placeDoorLR(xf + 1, y);
    }
    return true;
  });
};

randomMob = function() {
  var m, speed, x;
  speed = randomBetween(50, 150);
  x = Math.round((speed - 50) / 100 * 8);
  m = new Mob('ABCDEFGHI'.charAt(x));
  m.speed = speed;
  m.hp = randomBetween(5, 25);
  m.visibilityRadius = 4;
  return m;
};

p = null;

setup = function() {
  var halfx, halfy, i, inside, map, mob, pt, startPoint, x, xx, y, yy, _i, _j, _k, _l, _m;
  map = new Stage(80, 35);
  inside = map.insideArea(1);
  halfx = inside.mx / 2 | 0;
  halfy = inside.my / 2 | 0;
  for (xx = _i = 0; _i <= 1; xx = ++_i) {
    for (yy = _j = 0; _j <= 1; yy = ++_j) {
      x = randomIn(halfx * xx, halfx * (xx + 1));
      y = randomIn(halfy * yy, halfy * (yy + 1));
      makeTrail(inside, x, y, 12, 100);
    }
  }
  for (i = _k = 1; _k <= 15; i = ++_k) {
    makeRandomRoom(inside, 10, 7);
  }
  for (i = _l = 1; _l <= 40; i = ++_l) {
    mob = randomMob();
    pt = inside.randomPointWhere((function(_this) {
      return function(c) {
        return c.canEnter(mob);
      };
    })(this));
    inside.placeMob(pt, mob);
  }
  for (i = _m = 1; _m <= 20; i = ++_m) {
    pt = map.randomPointWhere((function(_this) {
      return function(c) {
        return c.terrain === Terrain.FLOOR && (c.item == null);
      };
    })(this));
    map.atPoint(pt).item = new Item('$');
  }
  p = new Mob("@");
  p.speed = 100;
  p.hp = 100;
  p.visibilityRadius = 10;
  startPoint = inside.randomPointWhere((function(_this) {
    return function(c) {
      return c.canEnter(p);
    };
  })(this));
  inside.placeMob(startPoint, p);
  return map;
};

updateMap = function() {
  var _ref;
  process();
  p.stage.updateVisibility(p, 10);
  showMap($('#map'), p.stage);
  return $('#info').html("HP: " + p.hp + "/100<br>Kills: " + p.kills + "<br>Items: " + ((_ref = p.items) != null ? _ref : 0));
};

showMap = function(el, map) {
  var buf, bufClass, cell, glyph, glyphClass, res, time, x, y, _i, _j, _ref, _ref1;
  res = $('<span>');
  time = map.timeline.time;
  buf = [];
  bufClass = null;
  for (y = _i = 0, _ref = map.my; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
    for (x = _j = 0, _ref1 = map.mx; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
      cell = map.at(x, y);
      if (cell.lastVisibleTime != null) {
        if (cell.lastVisibleTime < time) {
          glyph = cell.terrainGlyph();
          glyphClass = 'fog';
        } else {
          glyph = cell.toString();
          glyphClass = 'normal';
        }
        if (cell.feature === Feature.BLOODY && (cell.mob == null)) {
          glyphClass += ' bloody';
        }
      } else {
        glyph = '&nbsp;';
        glyphClass = 'unseen';
      }
      if (bufClass !== glyphClass) {
        if (bufClass !== null) {
          res.append("<span class=\"" + bufClass + "\">" + (buf.join('')) + "</span>");
        }
        buf = [glyph];
        bufClass = glyphClass;
      } else {
        buf.push(glyph);
      }
    }
    buf.push("<br/>");
  }
  res.append("<span class=\"" + bufClass + "\">" + (buf.join('')) + "</span>");
  return el.html(res);
};

move = function(dx, dy) {
  var c, grabItem, nx, ny;
  grabItem = function() {
    if (p.hp < 100 && (p.cell().item != null)) {
      if (p.items == null) {
        p.items = 0;
      }
      p.items += 1;
      p.cell().item = null;
      p.hp += 25;
      if (p.hp > 100) {
        return p.hp = 100;
      }
    }
  };
  if (!p.alive) {
    p.wait();
    grabItem();
    return true;
  }
  if (dx === 0 && dy === 0) {
    p.wait();
    return true;
  } else {
    nx = p.x + dx;
    ny = p.y + dy;
    c = p.stage.at(nx, ny);
    if (c.mob != null) {
      p.attack(c.mob);
      return true;
    } else {
      if (c.canEnter(p)) {
        p.moveTo(point(nx, ny));
        grabItem();
        return true;
      } else {
        return false;
      }
    }
  }
};

process = function() {
  var choice, choices, ctr, loc, mob, tl, _results;
  tl = p.stage.timeline;
  ctr = 0;
  _results = [];
  while (true) {
    if (ctr++ > 1000) {
      throw new Error("infloop in process");
    }
    mob = tl.advance();
    if (mob === p) {
      break;
    }
    choices = (function() {
      var _i, _len, _ref, _results1;
      _ref = mob.stage.adjacent(mob);
      _results1 = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        loc = _ref[_i];
        if (loc.cell.mob === p || loc.cell.canEnter(mob)) {
          _results1.push(loc);
        }
      }
      return _results1;
    })();
    if (mob.canSee(p)) {
      choice = _.min(choices, (function(_this) {
        return function(c) {
          return distance2(p.x, p.y, c.x, c.y);
        };
      })(this));
    } else {
      choice = randomOf(choices);
    }
    if (choice != null) {
      if (choice.cell.mob != null) {
        _results.push(mob.attack(choice.cell.mob));
      } else {
        _results.push(mob.moveTo(choice));
      }
    } else {
      _results.push(mob.wait());
    }
  }
  return _results;
};

$(function() {
  var map;
  $('#content').html("<div id=\"map\"></div>\n<div id=\"info\"></div>");
  map = setup();
  updateMap();
  return $(document).keydown(function(e) {
    var dx, dy, _ref;
    if (keyMap[e.which] != null) {
      _ref = keyMap[e.which], dx = _ref[0], dy = _ref[1];
      if (move(dx, dy)) {
        return updateMap();
      }
    }
  });
});
