// Generated by CoffeeScript 1.7.1
require(function(Cell, Region, Location, geom) {
  var Stage;
  return Stage = (function() {
    function Stage(w, h) {
      var i;
      this.w = w;
      this.h = h;
      this.grid = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.w * this.h; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(new Cell());
        }
        return _results;
      }).call(this);
      this.region = new Region(this, 0, 0, this.w, this.h);
    }

    Stage.prototype.at = function(p) {
      if (!this.isInside(p)) {
        return null;
      } else {
        return this.grid[p.y * this.w + p.x];
      }
    };

    Stage.prototype.loc = function(p) {
      if (!this.isInside(p)) {
        return null;
      } else {
        return new Location(this, p);
      }
    };

    Stage.prototype.isInside = function(p) {
      var _ref, _ref1;
      return (0 <= (_ref = p.x) && _ref < this.w) && (0 <= (_ref1 = p.y) && _ref1 < this.h);
    };

    Stage.prototype.updateVisibility = function(sourcePoint, radius) {
      var border, ctr, danger, finish, go, ox, oy, queue, seen, start, xx, yy;
      Cell.clearVisibility();
      go = function(pt) {
        if (seen.add(pt)) {
          queue.push(pt);
        }
      };
      this.at(sourcePoint).setVisible();
      start = sourcePoint.plus(pt(0.5, 0.5));
      border = sourcePoint;
      ctr = 0;
      seen = new geom.PointSet();
      ox = sourcePoint.x, oy = sourcePoint.y;
      queue = [];
      queue.push(start.plus(pt(1, 0)));
      danger = false;
      while (queue.length > 0) {
        if (ctr++ > 1000) {
          throw new Error("infloop!");
          break;
        }
        finish = queue.pop();
        geom.raycast(start, finish, radius, (function(_this) {
          return function(p) {
            var cell;
            border = p;
            cell = _this.at(p);
            if (cell == null) {
              return false;
            } else {
              cell.setVisible();
              if (cell.mob != null) {
                danger = true;
              }
              return !cell.isOpaque();
            }
          };
        })(this));
        xx = border.x, yy = border.y;
        if (xx > ox && yy <= oy || xx <= ox && yy > oy) {
          go(pt(xx, yy));
        }
        if (xx < ox && yy <= oy || xx >= ox && yy > oy) {
          go(pt(xx + 1, yy));
        }
        if (xx <= ox && yy < oy || xx > ox && yy >= oy) {
          go(pt(xx, yy + 1));
        }
        if (xx >= ox && yy < oy || xx < ox && yy >= oy) {
          go(pt(xx + 1, yy + 1));
        }
      }
      this.seeDanger = danger;
    };

    Stage.prototype.checkLOS = function(start, finish, radius, isPassable) {
      var i, j, saw, _i, _j;
      if (start.distance2(finish) > radius * radius) {
        return false;
      } else {
        saw = false;
        for (i = _i = 0; _i <= 1; i = ++_i) {
          for (j = _j = 0; _j <= 1; j = ++_j) {
            geom.raycast(start.plus(pt(0.5, 0.5)), finish.plus(pt(i, j)), radius, (function(_this) {
              return function(p) {
                var c;
                if (p.eq(finish)) {
                  saw = true;
                  return false;
                } else {
                  c = _this.at(p);
                  if ((c == null) || !isPassable(c)) {
                    return false;
                  } else {
                    return true;
                  }
                }
              };
            })(this));
            if (saw) {
              return true;
            }
          }
        }
        return false;
      }
    };

    Stage.prototype.toString = function() {
      return this.region.toString();
    };

    return Stage;

  })();
});
